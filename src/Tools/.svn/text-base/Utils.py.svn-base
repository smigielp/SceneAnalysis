# -*- coding: utf-8 -*-
'''
Created on 2010-09-02

@author: p
'''

import math


# Euclidean distance between two points
def getDistance(p1, p2):
    sum = 0
    for i in range(len(p1)):
        sum += abs(p1[i] - p2[i])**2
    return math.sqrt(sum)

def getCapacity(p1, p2):
    cap = 1
    for i in range(len(p1)):
        cap *= abs(p1[i] - p2[i])
    return cap

def getSphereCapacity(radius):
    return math.pi * radius**2 

def getCapacity2(array):
    cap = 1
    for dim in array:
        cap *= abs(dim[1] - dim[0])
    return cap

def getMiddlePointXD(cube, dimension):
    return [(cube[0][j] + cube[1][j])/2.0 for j in range(dimension)]

def getMiddlePoint(p1, p2):
    return [(p1[0]+p2[0])/2.0, (p1[1]+p2[1])/2.0]

def getMiddlePointByY(p1, p2, y):
    x1 = p1[0]
    y1 = p1[1]
    x2 = p2[0]
    y2 = p2[1]
    if y2 == y1:
        return None
    x = x1 + (x2 - x1)*(y - y1)/(y2-y1)
    return x

def getWeightCenter(vertex):
    sumX = sumY = 0
    for point in vertex:
        sumX += point[0]
        sumY += point[1]
    return [sumX/len(vertex), sumY/len(vertex)]

def rotate2D(point, center, alpha):    
    point0 = [point[i] - center[i] for i in range(len(point))]
    newPoint = []
    newPoint.append(math.cos(alpha) * point0[0] - math.sin(alpha) * point0[1])
    newPoint.append(math.sin(alpha) * point0[0] + math.cos(alpha) * point0[1])
    for i in range(len(newPoint)):
        newPoint[i] += center[i]
    return newPoint

def getLineAngle(p1, p2):
    len = getDistance(p1, p2)
    lenX = p2[0] - p1[0]
    #lenY = p2[1] - p1[1]    
    cosAlpha = lenX / len
    alpha = math.acos(cosAlpha) / math.pi
    if p2[1] < p1[1]:
        alpha = 2 - alpha    
    return alpha

def getLineAngle2(p1, p2):
    return getAngle([0,0],[0,1],[p1,p2])

def rotate3D(point, center, alpha):
    pass

#
# Funkcje dla szkieletyzacji i wydobywania linii szkieletu
#

def getElem(data, coord):
    tmp = data[coord[0]]
    for i in range(1,len(coord)):
        tmp=tmp[coord[i]]
    return int(tmp)

def setElem(data, coord, val):
    tmp = data[coord[0]]
    for i in range(1, len(coord)-1):
        tmp=tmp[coord[i]]
    tmp[coord[-1]] = val
 
    
# Służy obliczaniu odległości punktu od prostej 
# wyznaczonej przez dwa punktu
# (korzysta z nierówności Schwarza)

def pointToLineDist(beg, end, point):
    lenA = getDistance(beg, end)    
    lenB = getDistance(beg, point)
    if lenA == 0:
        return lenB
    if lenB == 0:
        return 0
    scalar = 0.0
    for i in range(len(beg)):
        # z przesunięciem do początku układu równań
        scalar += (end[i] - beg[i]) * (point[i] - beg[i])
    cosAlpha = scalar / (lenA * lenB)
    cosAlpha = min(1.0, cosAlpha)
    alpha = math.acos(cosAlpha)
    distance = lenB * math.sin(alpha)
    return distance

def getAngle2(center, first, second):
    lenA = getDistance(center, first)    
    lenB = getDistance(center, second)
    if lenA == 0 or lenB == 0:
        return lenB
    scalar = 0.0
    for i in range(len(center)):
        # z przesunięciem do początku układu równań
        scalar += (first[i] - center[i]) * (second[i] - center[i])
    cosAlpha = scalar / (lenA * lenB)
    cosAlpha = min(0.999, max(-0.999, cosAlpha))
    alpha = math.acos(cosAlpha)    
    return alpha/math.pi


def getAngle(center, first, second):
    x1 = first[0] - center[0]
    y1 = first[1] - center[1]
    x2 = second[0] - center[0]
    y2 = second[1] - center[1]
    angle = math.atan2(y2, x2) - math.atan2(y1, x1)
    return (angle / math.pi) % 2

def getCrossingPoint(p1, p2, p3, p4):
    x = y = None
    if( p1[0] == p2[0] and p3[0] == p4[0] or
        p1[1] == p2[1] and p3[1] == p4[1] ):
        return p2
    # pierwszy jest pionowo
    if p2[0] == p1[0]:
        x = p2[0]
        # drugi jest poziomo
        if p3[1] == p4[1]:
            y = p3[1]
        else:
            a2 = float(p3[1] - p4[1]) / float(p3[0] - p4[0])
            b2 = p3[1] - a2 * p3[0]
            y = a2 * x + b2
    # drugi jest pionowo
    if p3[0] == p4[0]:
        x = p3[0]
        # pierwszy jest poziomo
        if p2[1] == p1[1]:
            y = p2[1]
        else:
            a1 = float(p2[1] - p1[1]) / float(p2[0] - p1[0])
            b1 = p2[1] - a1 * p2[0]
            y = a1 * x + b1
    # pierwszy jest poziomo
    if p2[1] == p1[1]:
        y = p2[1]
        # drugi jest pionowo
        if p3[0] == p4[0]:
            x = p3[0]
        else:
            a2 = float(p3[1] - p4[1]) / float(p3[0] - p4[0])
            b2 = p3[1] - a2 * p3[0]
            x = (y - b2) / a2 
    # drugi jest poziomo
    if p3[1] == p4[1]:
        y = p3[1]
        if p2[0] == p1[0]:
            x = p2[0]
        else:
            a1 = float(p2[1] - p1[1]) / float(p2[0] - p1[0])
            b1 = p2[1] - a1 * p2[0]
            x = (y - b1) / a1
        
    if x != None and y != None:
        return [x, y]
    else:
        a1 = float(p2[1] - p1[1]) / float(p2[0] - p1[0]) 
        a2 = float(p3[1] - p4[1]) / float(p3[0] - p4[0])
        if a1 == a2:
            return p2        
        
        b1 = p2[1] - a1 * p2[0]
        b2 = p3[1] - a2 * p3[0]
    
        y = (a1*b2 - a2*b1) / (a1 - a2)
        x = (y - b1) / a1            
        return [x, y]
    
    
def getHausdorffDist(vertex1, vertex2):
    distV1 = 0
    for corner in vertex1:
        i = 1
        dist = 100000000
        while(i < len(vertex2)):
            dist = min(dist, pointToLineDist(corner, vertex2[i-1], vertex2[i])) # czy na pewno ta funkcja
            i += 1
        distV1 = max(distV1, dist)
    distV2 = 0
    for corner in vertex2:
        i = 1
        dist = 100000000
        while(i < len(vertex1)):
            dist = min(dist, pointToLineDist(corner, vertex1[i-1], vertex1[i]))
            i += 1
        distV2 = max(distV2, dist)
    return max(distV1, distV2)

#===========================================================
# oblicza dlugosc lamanej okreslonej jako ciag punktow
def getVertexLen(vertex):
    i = 1
    llen = 0
    while i < len(vertex):
        llen += getDistance(vertex[i], vertex[i-1])
        i += 1
    return llen

def getLongestVertex(multiList):
    llen = 0
    idx = 0
    for i, list in enumerate(multiList):
        vlen = getVertexLen(list)
        if vlen > llen:
            llen = vlen
            idx = i
    return multiList[idx]
