'''
Created on 2011-09-27

@author: piotrek
'''
from Tools import Utils
from copy import deepcopy
import math

class BorderVectors(object):
    
    def __init__(self, winSize, data = None):
        self.data = data
        self.windowSize = winSize
        self.window = []
        self.marker = 2
        radius = int(winSize/2)
        self.radius = radius
        self.angleStep = math.pi/8
        # kat o jaki musi zakrecac lamana zeby oznaczyc naroznik
        self.cornerAngle = 0.12
        # konstruowanie 4 krawedzi okna do poszukiwania nastepnego punktu obrysu
        tmp = range(-radius, radius)
        for i in tmp:
            self.window.append([-radius,i])
        for i in tmp:
            self.window.append([i,radius])
        tmp = range(-radius+1, radius+1)
        tmp.reverse()
        for i in tmp:
            self.window.append([radius, i])
        for i in tmp:
            self.window.append([i, -radius])
        self.window = self.window + self.window
        
    def setData(self, data):
        self.data = data
        
    def getNextUnmarkedPoint(self, fromCoord):
        i = fromCoord[0]
        while i < len(self.data):
            j = 0
            while j < len(self.data[0]):
                if int(self.data[i][j]) == 2:
                    while j < len(self.data[i]) and int(self.data[i][j]) >= 1:
                        j += 1
                elif int(self.data[i][j]) == 1:
                    marked = 0
                    for k in range(i-self.radius*2, i+self.radius*2+1):
                        for m in range(j-self.radius*2, j+self.radius*2+1):
                            if(fromCoord != [k,m] and self.isMarked([k, m])):
                                marked = 1                 
                    if(marked == 1):
                        # wyjscie poza bryle, ktora jest juz obwiedziona
                        while j < len(self.data[i]) and int(self.data[i][j]) >= 1:
                            j += 1
                    else:    
                        #if int(self.data[i+1][j-1]) == 1:
                            # znalezienie wlasciwego naroznika
                        #    while j+1 < len(self.data[i]) and int(self.data[i][j+1]) == 1: 
                        #        j += 1
                        return [i, j]   
                j += 1
            i += 1
        return None
    
    def getNextNeighbour(self, pointSeq, coord):
        i = len(self.window)/2
        # jesli dotarlismy juz do pierwszego punktu konczymy
        if Utils.getDistance(pointSeq[0], coord) <= self.radius * 2 and len(pointSeq) > 20:
            return None
        # jezeli naroznik "okna przeszukiwania" wskazuje na punkt poza obrysem budynku
        # przeszukujemy zgodnie ze wskazowkami zegarka
        # w przeciwnym razie odwrotnie
        if self.data[coord[0]+self.window[i][0]][coord[1]+self.window[i][1]] == 0:
            i += 1
            #print '----------------'
            #print i, self.window
            #print self.data[coord[0]][coord[1]]
            while self.data[coord[0]+self.window[i][0]][coord[1]+self.window[i][1]] != 1: # and i < len(self.window):               
                #print i, self.window[i][0], self.window[i][1], self.data[coord[0]+self.window[i][0]][coord[1]+self.window[i][1]]
                #print len(self.window), i, [coord[0]+self.window[i][0], coord[1]+self.window[i][1]]
                i += 1
        else:            
            while self.data[coord[0]+self.window[i-1][0]][coord[1]+self.window[i-1][1]] == 1: # and i >= 0:
                i -= 1
        if i >= len(self.window) or i <= 0:
            return None
        else:
            return [coord[0]+self.window[i][0], coord[1]+self.window[i][1]]            
      
             
    def isMarked(self, coord):
        return int(Utils.getElem(self.data, coord)) >= 2
        
    def markPoint(self, coord):
        Utils.setElem(self.data, coord, self.marker)
        
    def extractBorders(self):
        self.finalPoints = []
        beg = self.getNextUnmarkedPoint([0, 0])
        while(beg != None):
            vectors = self.goAroundObject(beg)
            self.finalPoints.append(vectors)
            beg = self.getNextUnmarkedPoint(beg)
            #beg = None
                        
    def goAroundObject(self, beg):
        part = [beg]
        self.markPoint(beg)
        next = self.getNextNeighbour(part, beg)
        while(next != None):
            part.append(next)
            self.markPoint(next)
            next = self.getNextNeighbour(part, next)
        part.append(deepcopy(part[0]))
        return part
            
                            
    def makeSmooth(self):
        vertexList = []
        # dla kazdego wieloboku v
        for v in self.finalPoints:
            if len(v) > 3:
                vertex = []                    
                vertex.append(v[0])
                angle = 1
                anglePrev = 1
                lastIdx = 0
                i = 3
                while i < len(v)-2:
                    anglePrevPrev = anglePrev
                    anglePrev = angle                    
                    #angle = Utils.getAngle(v[i-1], v[i-2], v[i])
                    angle = Utils.getAngle(v[i], v[i-1], v[i+1])
                    #if angle + anglePrev + anglePrevPrev > 3 + self.cornerAngle or \
                    #    angle + anglePrev + anglePrevPrev < 3 - self.cornerAngle:
                    if angle + anglePrev > 2 + self.cornerAngle or \
                        angle + anglePrev < 2 - self.cornerAngle:
                    #if angle > 1 + self.cornerAngle or \
                    #    angle < 1 - self.cornerAngle:
                        
                        # jezeli poprzedni punkt zostal dodany to pomijamy ten, 
                        # zeby nie dublowac punktow naroznika
                        if(i >= 3
                           and Utils.getDistance(vertex[-1], v[i]) > self.radius * 3 
                           and Utils.getDistance(v[-1], v[i]) > self.radius * 3
                           #and i - lastIdx > 3
                           #and len(v) - i > 3
                           ):
                            # dodanie punktu informujacego o umiejscowieniu naroznika
                            # wyliczenie wlasciwego naroznika w pozniejszej petli
                            vertex.append(v[i])
                            vertex.append([-1,-1])
                            vertex.append(v[i+1])
                            lastIdx = i
                    i += 1
                    
                vertex.append(v[-1])
                
                # wyznaczenie wlasciwych naroznikow                
                i = 1
                newVertex = [vertex[0]]
                #newVertex = []
                while i < len(vertex):                    
                    if vertex[i] == [-1, -1]:
                        # jezeli napotkany naroznik jest odosobniony to wyznaczamy jego wlasciwa pozycje
                        if vertex[i-2] != [-1, -1] and vertex[i+2] != [-1, -1]:
                            newCorner = Utils.getCrossingPoint(vertex[i-2], vertex[i-1], vertex[i+1], vertex[i+2])
                            newVertex.append(newCorner)
                        # w przeciwnym wypadku naroznik nalezy do ciagu naroznikow
                        # czyli nalezy na przyklad do obrysu zaokraglonej sciany 
                        else:
                            newVertex.append(vertex[i-1])
                    i += 1
                newVertex.append(vertex[0])
                
                vertexList.append(newVertex)
            else:
                vertexList.append(v)
        self.finalPoints = vertexList
        
        
#============================================================
# Funkcje realizujace kompletne zadania
#============================================================
def getCorners(matrix, step):
    vcr = BorderVectors(step)        
    vcr.setData(matrix)
    vcr.extractBorders()
    vcr.makeSmooth()
    return vcr.finalPoints
        
        